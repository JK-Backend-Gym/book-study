## 처리율 제한 장치 (rate limiter)

* Client나 서비스가 보내는 트래픽의 처리율을 제어하는 장치
* e.g) Open API에서 특정 사용자가 1분에 1000건 이상의 요청을 보내지 못하도록 제한
* 이를 통해, DDOS 같은 공격을 방어할 수 있고 봇이나 의도적인 사용자 공격에 방어할 수 있다.

---
### Rate Limiter를 컴포넌트로 구성 / Application 내의 소스코드로 구현
* Rate Limiter를 별도의 컴포넌트로 구성 : API 요청 시마다 WAS 전에 Rate Limiter 컴포넌트를 거치도록 구성한다. (일반적으로 API Gateway)
* Application 내의 소스코드로 구현 : Application 내의 로직이 실행될 때마다 Rate Limiter 로직이 수행되도록 구성한다. (bucket4j, Resilience4j, ...)
  * Bucket4j : 토큰 버킷 알고리즘
    * 버킷 내에 토큰이 있고, 요청 처리 시마다 토큰이 사용된다.
    * 요청이 왔을 때 버킷에 토큰이 없다면, 해당 요청은 거부된다.
    * 토큰은 정한 일정 시간마다 버킷에 채워진다.
    * 일반적으로 버킷은 Rate Limiter를 적용할 API 하나당 한개씩 둔다.
    * 단점 : 분산 환경에서 토큰 관리 시 원자성 보장을 위해 추가적인 로직을 사용해야 한다.
  * Resilience4j : 고정 윈도우 카운터 알고리즘
    * 고정된 시간 단위의 윈도우를 설정하고, 해당 윈도우 안에 최대 처리량(threshold)를 정한다.
    * 해당 윈도우 내의 최대 처리량을 초과한 요청은 거부된다.
    * 단점 : 윈도우 경계 지점에서 부하가 많이 발생 할 수 있다.
      * e.g) 윈도우 경계를 1분으로 설정하고 최대 처리량을 10으로 설정했을 떄, 04:59에 요청이 10개가 들어오고 05:01에 요청이 10개가 들어온다면 2분동안의 20개의 처리를 기대했지만 실제로는 2초만에 20개의 처리를 한셈이 된다.



---
### 분산 환경에서 Rate Limiter 구현
* Rate Limiter 카운터를 저장하는 저장소를 생각해야 한다.
* 일반적으로 Rate Limiter 오픈소스를 사용하면 JVM Heap 인메모리에 카운터를 저장한다.
* 분산 환경에서 인메모리에 저장하는 것은 적절하지 않으므로 외부 저장소를 두어 관리해야 한다.
* 일반적으로 Redis를 사용하는데, 단순 값을 증가시키는 `INCR` 커맨드는 적절하지 않다.
  * 책에 나온 단순 Race Condition 문제는 `INCR` 커맨드를 사용하면 원자성이 보장되므로 해결할 수 있다.
  * Bucket4j 같은 토큰 버킷 알고리즘에서 '토큰이 몇개 남았는지'만 중요한게 아니라, '토큰을 언제 채울지'도 중요하다.
  * 따라서, 마지막으로 토큰을 충전한 시간도 비교해야 한다.
  * 이러한 과정을 하나의 커맨드가 아닌 여러 커맨드를 섞어서 원자성을 보장하기 위해 Lua Script를 사용한다. (Bucket4j-Redis)

※ 책에 나온 원자성 보장을 위해 Sorted Set을 이용하는 방법은 사실상 `MULTI` 커맨드로 트랜잭션처럼 여러 명령어를 원자성 보장하는 건데, 결과에 따른 IF문 같이 커스텀이 어려워서 Lua Script를 더 많이 사용한다.

---
### Rate Limiter가 필요한 경우
* Public API
  * 사내가 아닌 외부에 공개하는 Open API 같은 경우
  * 외부 호출을 허용하는 Display API 같은 경우
* Private API
  * 사내 여러 서비스가 붙어서 사용할 수 있는 플랫폼 API (특정 호출자의 잦은 요청으로 인해 다른 호출자의 영향을 주면 안된다. 그 전에 방지)

  
---
### Lua Script 예제
[Redis Lua Script를 이용해서 API Rate Limiter 개발 (G마켓)](https://dev.gmarket.com/69)


