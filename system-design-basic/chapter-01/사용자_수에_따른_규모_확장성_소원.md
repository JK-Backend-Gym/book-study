### 1. 서버 확장 전략 및 로드 밸런싱

- **스케일업 VS 스케일 아웃**
    - 스케일업
        - 스케일업은 서버의 스펙을 상승시키는 것으로 상승시킨 스펙만큼의 비용대비 효율(비례하지 않음)은 나오지 않지만 가장 간단한 방법
    - 스케일 아웃
        - 이론상 무한 확장이 가능하고, 한 대가 죽어도 다른 서버가 대체 가능. 안정성과 가용성이 늘어나지만 로드밸런싱이 필수, 데이터 동기화가 들어가야함
    - 쿠버네티스 오토스케일링
        - HPA: CPU/Memory 부하에 따라 **파드의 개수**를 늘림
        - VPA: 파드의 개수는 그대로 두고 파드에 할당된 CPU/Memory 자원 할당량을 조절
    
    | 상황 | 원인 | 조치 | 확장 방식 |
    | --- | --- | --- | --- |
    | OOM (힙메모리 부족) | JVM 내 객체 할당 공간 부족 | -Xmx (Heap size) | 스케일업 |
    | CPU 사용률 90% 이상 + 응답 지연 | 요청 처리 연산량 과부하 | CPU Core 추가 또는 Pod 개수 추가 | 둘 다 가능 |
    | K8s Pod가 OOMKilled로 계속 재시작 | 컨테이너 허용 메모리 초과 | Resources Limit (컨테이너 자체 메모리 사이즈) | 스케일업 |
    | 트래픽 급증으로 모든 Pod 부하 | 동시 접속자 수 증가 | HPA (Pod Replicas) | 스케일아웃 |
- **로드밸런싱**
    
    클라이언트의 트래픽을 여러 대의 서버에 균등하게 분산시켜 특정 서버의 부하를 줄이고, 시스템 전체의 성능, 안정성을 높이는 기술
    
    | **구분** | **L4 (NLB)** | **L7 (ALB)** |
    | --- | --- | --- |
    | **계층** | Transport Layer (TCP/UDP) | Application Layer (HTTP/HTTPS) |
    | **판단 근거** | IP, 포트번호, 프로토콜 | URL, 헤더, 쿠키, 페이로드 |
    | **특징** | 데이터 패킷 단위 분산, 매우 빠름 | 콘텐츠 기반 라우팅, 세밀한 제어 가능 |
    | **주요 사례** | 게임 서버, 대규모 TCP 트래픽 | 일반적인 웹 서비스, 마이크로서비스(MSA) |
    - **L7 (ALB)**
        - **Sticky Session**
            - 기본적으로 로드밸런서는 Stateless하게 동작한다. 그러나 필요 시 쿠키를 이용해 특정 클라이언트를 특정 서버로 고정할 수 있다
            - Sticky Session 사용시 특정 서버에 트래픽이 몰려 로드밸런싱의 본래 목적이 깨질 수 있음. 선택시 고려 필요.
            
            > 로드밸런서단의 sticky session을 사용하기 보다 redis같은 스토리지를 사용하는 것이 더 표준 아키텍처에 가까움
            > 
    - **L4 (NLB)**
        - IP와 포트만 보고 전달하므로 L7보다 처리 속도가 빠르고 효율적
    - **자체 구축**
        - 비용 절감이나 커스텀이(Nginx, HAProxy 등)이 필요할 때 직접 EC2 등에 구성
        - **장점:** 프록시 설정, 화이트리스트 관리 같은 커스텀하기 좋음
        - **단점:** 관리할게 많음
    - 알고리즘
        - Round Robin
            - 서버에 순차적으로 요청을 배정
            - AWS ALB의 기본 알고리즘
        - Least Connection
            - 현재 연결중인 세션 수가 가장 적은 서버로 배정
            - 요청 처리 시간이 제각각인 서비스에 유리하다
        - Consistent Hashing
            - 단순 해싱은 서버가 추가/삭제 되면 key에 영향을 많이 주지만, Consistent Hashing은 해시 링 구조를 사용하여 서버 추가/제거 시 재배치되는 키의 양을 최소화 할 수 있음
                
                ![image.png](attachment:5a5234a6-f3dd-420e-a515-5fe2565e5a4e:image.png)
                
            - 주로 Redis Cluster, Kafka에 사용
            - 웹소켓통신의 경우 http요청과 달리 응답을 주면 끝 형태가 아니라서 해당 알고리즘을 사용하는 방식이 가장 좋음. 실제로 discord는 이 방식으로 웹소켓의 연결을 관리한다고 함.
    - **Spring Cloud Gateway**
        - 로드밸런서는 부하분산을 위한 장치
        - 스프링 클라우드 게이트웨이는 애플리케이션 단일 진입 지점(게이트웨이)으로 라우팅, 인증/인가, 변환, 속도 제한, 서킷브레이커 같은 비즈니스적인 측면이 강함
        ****
        
        ```mermaid
        flowchart TD
            Client[클라이언트]
            Client --> ALB[AWS ALB: 외부 진입점]
        
            subgraph "API Gateway Layer"
                ALB --> SCG[Spring Cloud Gateway]
                SCG -- "1. 유효성 검사" --> Redis[(Redis: Rate Limit/Session)]
            end
        
            subgraph "Service Discovery"
                SCG -. "2. 주소 조회" .-> Discovery[Service Discovery: Consul/Eureka]
            end
        
            subgraph "Microservices"
                SCG -- "3. 라우팅 (Internal LB)" --> AuthService[Auth Service]
                SCG -- "3. 라우팅 (Internal LB)" --> UserService[User Service]
                SCG -- "3. 라우팅 (Internal LB)" --> OrderService[Order Service]
                
                OrderService --> Kafka{Message Broker: Kafka}
            end
        
            AuthService --> AuthDB[(Auth DB)]
            UserService --> UserDB[(User DB)]
        ```
        
        - service discovery는 대표적으로 유레카, **콘설**, Zookeeper
        - Eureka VS Consul
            - 유레카는 이제 잘 안 씀. 콘설로 가는 추세. 헬스 체크 기준이 다름. 유레카는 헬스체크를 조금 러프하게 하는 경향이 있음. 또 유레카의 경우 스프링 생태계에 친화적인데 콘설은 멀티 환경이라 확장성에 유리함.

### 2. 데이터베이스 설계 및 고도화

- 여러 DBMS
    - RDBMS
        - 트랜잭션 보장
        - 컬럼타입, 제약조건으로 클린한 데이터 유지 가능
        - B+Tree라 인덱스만 타면 O(logN) 근데 파티셔닝하면 이것도 좀 고려해야함.
        - RDBMS에 인덱스를 적절히 거는 것에 유의해야함
            
            → insert, update 병목 및 lock 발생
            
    - NoSQL
        - 유연한 스키마와 확장성
        - 빠른 조회 O(1)
        - 비즈니스가 복잡하고 큰 경우 유지보수에 어려움
        - redis, mongo
    - NewSQL
        - CockroachDB, NuoDB, Google Spanner, VoltDB
        - RDBMS + NoSQL 인데 나온지는 몇 년 됐는데 그닥 많이 사용되지는 않는듯
    - vector DB
        - AWS opensearch, pinecon
- **DB 다중화, 동기화**
    - 바이너리 로그 복제
        - Master와 ReplicaDB가 구분되어 있을 때 데이터를 동기화 하는 방법
        - DB 엔진이 트랜잭션을 처리하면서 남기는 바이너리 로그 자체를 그대로 다른 DB에 전달하고 재생하는 방식
    - CDC
        - CDC는 DB의 데이터 변경을 이벤트로 취급하며 다른 시스템에 전파하는 것
        
        ```mermaid
        flowchart TD
            MSSQL[MSSQL<br/>Source DB]
            CDC[Kafka Connect<br/>Debezium CDC]
            Kafka[Kafka Topic]
            Postgres[PostgreSQL<br/>Target DB]
        
            MSSQL -->|CDC 변경 로그| CDC
            CDC --> Kafka
            Kafka --> Postgres
        ```
        
- **대규모 데이터 관리**
    - 파티셔닝
        
        테이블 또는 인덱스 데이터를 파티션 단위로 나누어 저장하는 것을 말한다. 물리적으로 나누는 것.
        
        - 수직 파티셔닝
        - 수평 파티셔닝
            - range(일반적), list, hash
    - 샤딩
        - DB자체를 여러대로 증설하는 것. JOIN 불가
    - 클러스터링
        - 클러스터링 인덱스는 PK에 자동할당되는 인덱스인데 auto increment로 쓰면 자동 증가니까 상관 없고 UUID를 쓸 때에는 v4말고 v7 / ULID / KSUID (시간 정렬)을 쓰는 게 좋다.

### 3. 캐시와 CDN

- **애플리케이션 캐싱**
    - **캐시 전략**
        - **Look-aside(cache aside)**
            - DB 조회 시 먼저 캐시 확인. 캐시에 없으면 DB 조회 후 캐시에 저장
        - **Write-through**
            - DB 쓰기 시 캐시도 동시에 업데이트. 캐시와 DB 동기화가 되지만 쓰기 지연 발생 가능
        - **Write-back**
            - 캐시에 먼저 쓰고 일정 시점에 DB에 반영. 장애 시 데이터 손실 가능
    - **Memcached vs Redis**
        - **Memcached**
            - 순수 메모리캐시
            - 단일 서버/소규모 환경에서만 사용
        - **Redis**
            - 다양한 자료구조, 기능(Pub/Sub, TTL) 지원
            - 다양한 모드가 있다.
                - spring에서 config하는 방법이 다르니 주의해야됨.
                - TLS 세팅도 다 다름
                - AWS에서는 **ElastiCache Redis**에서 Valkey 사용
                1. 단일
                2. sentinel
                    - 여러 slave에 데이터가 복제됨
                    
                    ```mermaid
                    graph TD
                        subgraph Sentinel 환경
                            M[Master]
                            S1[Slave 1]
                            S2[Slave 2]
                            Sent[Sentinel 감시]
                        end
                    
                        M -->|쓰기/읽기| S1
                        M -->|쓰기/읽기| S2
                        Sent --> M
                        Sent --> S1
                        Sent --> S2
                    
                    ```
                    
                3. cluster
                    - 키를 해시하여 노드를 찾음
                    - master, slave묶어서 샤딩
                    - 여러 slave에 데이터가 분산됨
                    
                    ```mermaid
                    graph TD
                        subgraph Cluster 환경
                            MA[Master A - Slot 0~5460]
                            MB[Master B - Slot 5461~10922]
                            MC[Master C - Slot 10923~16383]
                            
                            SA[Slave A1]
                            SB[Slave B1]
                            SC[Slave C1]
                        end
                    
                        MA -->|복제| SA
                        MB -->|복제| SB
                        MC -->|복제| SC
                    
                        Client -->|키→슬롯 계산→Master A| MA
                        Client -->|키→슬롯 계산→Master B| MB
                        Client -->|키→슬롯 계산→Master C| MC
                    
                    ```
                    
    - **캐시 스탬피드**
        - 동일 키 만료 시 다수 요청이 DB로 몰리는 현상
        - **대책**
            - **Locking / Mutex**: 한 요청만 DB 조회 후 캐시 업데이트
            - **Early Refill / Random TTL**: 만료 시간 랜덤화
            - **Request Coalescing**: 캐시 미스 시 요청 합치기
- **CDN**
    
    기본적으로는 정적 리소스를 엣지서버에 캐싱해두어서 응답 속도를 빠르게 함
    
    - 정적 리소스 가속 및 에지 로케이션(Edge Location) 활용.
    - 무효화 전략
        - 버저닝
            - 파일명에 해시/버전/날짜 포함 → 기존 캐시 무효화 없이 새 버전 배포
        - api를 통한 무효화
            - CloudFront API를 통한 직접 삭제. 지연 있음.
            - application에서 인프라 조작이 되는게 아키텍처상 좋은걸까?
    - **Edge Computing**
        - CF Function: 경량 JavaScript 실행
            - 도메인이 분산되어있는 경우 CF function redirect를 통한 중앙화 가능
            - 빠르고 저렴하고 제한된 기능
        - Lambda@Edge
            - 기능은 더 많지만 비용이 많이 발생

> 자주 조회되고 자주 수정되는 데이터에 대한 캐싱과 CDN전략을 어떻게 세우면 좋을까?
> 

### 4. 메시징

- Kafka(고성능 대용량, 로그 보관), RabbitMQ(커스텀), SQS(AWS 간편)
- 메시지 전달 보장 전략
    - **At-most-once:** 메시지가 **최대 한 번만 전달**
    - **At-least-once:** 메시지가 **최소 한 번 전달 (일반적인 사용)**
    - **Exactly-once:** 메시지가 **정확히 한 번 처리**
    
    > kafka는 언제든지 중복이 발생할 수 있다는 것을 전제로 두고 처리한다. 중복에 대한 제한은 application 단에서 처리
    > 
    - Kafka와 DB 트랜잭션 불일치를 방지하기 위한 방법
        - outbox패턴 구현 사례
            - https://medium.com/@greg.shiny82/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%94%EB%84%90-%EC%95%84%EC%9B%83%EB%B0%95%EC%8A%A4-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%8B%A4%EC%A0%9C-%EA%B5%AC%ED%98%84-%EC%82%AC%EB%A1%80-29cm-0f822fc23edb
        - 예시 아키텍처
            
            ```mermaid
            sequenceDiagram
                autonumber
            
                participant Client
                participant BFF
                participant OrderService
                participant OrderDB
                participant OutboxPublisher
                participant Kafka
                participant PaymentService
                participant PaymentDB
            
                Client ->> BFF: 주문 생성 요청
                BFF ->> OrderService: CreateOrder
            
                OrderService ->> OrderDB: BEGIN TX
                OrderService ->> OrderDB: INSERT orders
                OrderService ->> OrderDB: INSERT outbox_events (ORDER_CREATED)
                OrderService ->> OrderDB: COMMIT TX
            
                Note right of OrderDB: 주문 데이터와 이벤트가\n같은 트랜잭션으로 확정됨
            
                OutboxPublisher ->> OrderDB: SELECT outbox_events WHERE status=NEW
                OutboxPublisher ->> Kafka: Publish ORDER_CREATED
                OutboxPublisher ->> OrderDB: UPDATE outbox_events SET status=SENT
            
                Kafka ->> PaymentService: ORDER_CREATED 이벤트 전달
                PaymentService ->> PaymentDB: 결제 준비 처리 (멱등성 보장)
            
            ```
            
- 처리 실패한 메시지
    - DLQ 를 통한 CS 처리

### 5. **로깅 & 모니터링**

1. **AWS 로그 및 메트릭**
    - VPC Flow Logs: 네트워크 레벨 로그
    - ALB Access Logs: 로드밸런서 레벨 로그
    - **CloudWatch: 기본 인프라 상태 모니터링**
2. **ELK** (Elasticsearch + Logstash + Kibana)
    - 로그 수집(Logstash), 저장/검색(Elasticsearch), 시각화(Kibana)
    - 오픈소스, 대량 로그 처리, 실시간 검색 가능
    - 전통적인 느낌
3. OpenTelemetry
    - 표준화된 **로그, 메트릭, 트레이싱 통합 수집**
4. Grafana
    - 시각화 및 대시보드
5. Loki
    - Grafana 생태계용 로그 DB
6. **AWS OpenSearch**
    - AWS의 Elasticsearch 서비스
